#summary Explanations of non-obvious stuff.

===1) Why did you map cells and rows the way you did? If you don't mind using non-JPA Hibernate annotations, then why didn't you use `@IndexColumn`?===

We were originally doing it like this:

{{{
@Entity
public class CharacterStateRow {
    ...
    @OneToMany
    @org.hibernate.annotations.IndexColumn(name="position")
    @JoinColumn(name="CHARACTER_STATE_ROW_ID", nullable=false)
    private List<Child> children;
    ...
}

@Entity
public class CharacterStateCell {
    ...
    @ManyToOne
    @JoinColumn(name="CHARACTER_STATE_ROW_ID", insertable=false, updatable=false, nullable=false)
    private CharacterStateRow row;
    ...
}
}}}

but it was too slow on at least saves. This was because it performed many extra updates for unknown reasons - maybe because it needs to manage the ordering of the list and can only update the position column after all the members have been set?  `CharacterStateMatrix->CharacterStateRow` was done the same way because it was developed at the same time. It also seems nice for consistency's sake. 

===2) If what you say in rationale 1 is true, why did you proceed to do it with `CharacterStateMatrix->Character`?===

Because that is a many-to-many relationship and we didn't know how to do it otherwise. Plus, there're aren't as many `Character`s as there are cells and so performance problems - if any - wouldn't be as amplified.

===3) But then why is `TreeSet->Tree` done with an `@IndexColumn` and join table?===

Because it used to be many-to-many and since there're are so few trees in tree sets it didn't seem worth it to change.