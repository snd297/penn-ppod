#summary Explanations of non-obvious stuff.

===1) Why did you map cells and rows the way you did?===

We were originally doing it like this (from http://docs.jboss.org/hibernate/stable/annotations/reference/en/html/entity.html#entity-hibspec-collection-enhance):

{{{
@Entity
public class Parent {
    @OneToMany
    @org.hibernate.annotations.IndexColumn(name="order")
    @JoinColumn(name="parent_id", nullable=false)
    private List<Child> children;
    ...
}

@Entity
public class Child {
    ...
    @ManyToOne
    @JoinColumn(name="parent_id", insertable=false, updatable=false, nullable=false)
    private Parent parent;
    ...
}
}}}

but it was too slow on at least saves. This was because it performed many extra updates for unknown reasons - maybe because it needs to manage the ordering of the list and can only update the position column after all the members have been set?  `CharacterStateMatrix->CharacterStateRow` was done the same way because it was developed at the same time. It's also seems nice for consistency's sake. 

===2) If what you say in rationale 1 is true, why did you proceed to do it with `CharacterStateMatrix->Character`?===

Because that is a many-to-many relationship and we didn't know how to do it otherwise. Plus, there're aren't as many `Character`s as there are cells and so performance problems - if any - wouldn't be as amplified.

===3) But then why is `TreeSet->Tree` done with an `@IndexColumn` and join table?===

Because it used to be many-to-many and since there're are so few trees in tree sets it didn't seem worth it to change.